(ns bru-9.scenes.throwups
  (:require [bru-9.color.core :as c]
            [bru-9.color.infinite :as ci]
            [bru-9.field.core :as f]
            [bru-9.field.linear :as fl]
            [bru-9.geom.bezier :as b]
            [bru-9.geom.brush :as br]
            [bru-9.util :as u]
            [bru-9.geom.ptf :as ptf]
            [thi.ng.geom.core :as g]
            [thi.ng.geom.vector :as v]
            [thi.ng.math.core :as m]
            [thi.ng.geom.webgl.glmesh :as glm]
            [thi.ng.geom.attribs :as attr]
            [bru-9.color.infinite :as ci]
            [bru-9.interop :as i]
            [thi.ng.color.core :as tc]))

(defn sample-brush [brushfn]
  (let [sample-count 100
        bfn (fn [i] (brushfn (/ i (dec sample-count))))]
    (map bfn (range sample-count))))

(def brushes
  {
   :sine05 (sample-brush #(br/sine % 0.005 m/PI 3 2))
   :sine09 (sample-brush #(br/sine % 0.009 m/PI 3 2))
   :sine11 (sample-brush #(br/sine % 0.011 m/PI 3 2))
   :sine15 (sample-brush #(br/sine % 0.015 m/PI 3 2))

   ;:wobble24 (sample-brush #(br/wobbler % 0.24))

   ;:spiky40 (sample-brush #(br/two-sided-spikes % 0.4 5))
   ;:spiky24 (sample-brush #(br/two-sided-spikes % 0.24 5))
   ;:spiky12 (sample-brush #(br/two-sided-spikes % 0.12 5))
   ;:spiky6 (sample-brush #(br/two-sided-spikes % 0.06 5))

   ;:sine (sample-brush #(br/sine % 0.5 (rand m/TWO_PI) 5 1))
   :rotating-quad4 (sample-brush #(br/rotating-quad % 0.04 m/HALF_PI))
   :rotating-quad8 (sample-brush #(br/rotating-quad % 0.08 m/HALF_PI))
   :noise-quad (sample-brush #(br/noise-quad % 0.4))
   })

(def config {:background-color 0x111111
             :start-positions-hops 200
             :start-positions-axis-following 2.0
             :start-positions-walk-multiplier 0.03
             :curve-tightness-min 0.04
             :curve-tightness-max 0.1
             :spline-hops 5
             :offset-radius 0.05
             :field-dimensions [10 5 5]
             :field-count 2
             :field-general-direction v/V3X
             :field-random-following 1.0
             :mulfn-base 0.7
             :mulfn-jump-chance 0.2
             :mulfn-jump-intensity 1.2
             :wander-probability 0.25
             :spline-resolution 10
             :mesh-geometry-size 131070
             :brushes (vals brushes)
             :infinite-params {:hue 0.1
                               :saturation 0.1
                               :brightness 0.0}
             :rotation-speed 0.00015
             :camera-distance 20})

(defn- mulfn [_]
  (let [{:keys [mulfn-base mulfn-jump-chance mulfn-jump-intensity]} config]
    (+ mulfn-base (if (< (rand) mulfn-jump-chance) mulfn-jump-intensity 0))))

(defn- field-generator [_ random-intensity direction]
  (m/+ direction (v/randvec3 random-intensity)))

(defn- make-directions [initial count]
  (loop [dirs [initial], i count]
    (if (> i 0)
      (recur (conj dirs (m/- (last dirs))) (dec i))
      (rest dirs))))

(defn- make-fields []
  (let [{:keys [field-count
                field-general-direction
                field-random-following
                field-dimensions]} config
        dirs (make-directions field-general-direction field-count)
        fgen (fn [_ dir] (field-generator _ field-random-following dir))
        constructor (fn [dir] (fl/linear-field field-dimensions #(fgen % dir)))]
    (map constructor dirs)))

(defn- make-start-positions-field [direction]
  (let [random-follow (:field-random-following config)]
    (fl/linear-field (:field-dimensions config)
                     #(field-generator % random-follow direction))))

(defn- make-start-positions [field]
  (let [mulfn (fn [_] (:start-positions-walk-multiplier config))]
    (f/walk field v/V3 (:start-positions-hops config) mulfn)))

(def start-positions
  (->> (:start-positions-axis-following config)
       (m/* (:field-general-direction config))
       make-start-positions-field
       make-start-positions))

(defn- make-field-splines
  "Returns a collection of splines generated by walking the given fields."
  [fields]
  (let [{:keys [spline-hops
                offset-radius
                curve-tightness-min
                curve-tightness-max
                wander-probability]} config
        offset-positions (map #(m/+ % (v/randvec3 offset-radius))
                              start-positions)]
    (map #(b/spline-wander fields % (+ 2 (rand-int (- spline-hops 2))) mulfn
                           (u/rand-range curve-tightness-min
                                         curve-tightness-max)
                           wander-probability)
         offset-positions)))

(defn- draw-fields
  "Draws the given field using the given infinite palette. Returns the splines."
  [scene fields palette]
  (let [mesh-acc (glm/gl-mesh (:mesh-geometry-size config) #{:col})
        res (:spline-resolution config)
        brushes (:brushes config)
        splines (make-field-splines fields)
        generate-profiles
        (fn [count brush]
          (let [mfn
                (fn [i]
                  (let [t (/ i (dec count))]
                    (u/nth01 brush t)))]
            (map mfn (range count))))
        ptf-spline
        (fn [acc spline color]
          (let [colors (attr/const-face-attribs (repeat color))
                vertices (g/vertices spline res)
                brush (rand-nth brushes)]
            (ptf/sweep-mesh vertices
                            (generate-profiles (count vertices) brush)
                            {:mesh acc, :attribs {:col colors}})))
        mesh (reduce #(ptf-spline %1 (first %2) (second %2))
                     mesh-acc
                     (map vector splines palette))
        three-mesh (i/three-mesh mesh)]
    (.add scene three-mesh)
    splines))

(defn- calculate-x-extents [splines]
  (let [extfn
        (fn [[min max] point]
          [(if (< (:x point) (:x min)) point min)
           (if (> (:x point) (:x max)) point max)])
        all-points (mapcat :points splines)]
    (reduce extfn [(first all-points) (first all-points)] all-points)))

(defn- setup-camera [camera pivot-pos]
  (set! (.-x (.-position camera)) (.-x pivot-pos))
  (set! (.-y (.-position camera)) 0)
  (set! (.-z (.-position camera)) (:camera-distance config))
  (.lookAt camera pivot-pos))

(defonce camera-pivot (THREE.Object3D.))

(defn setup [initial-context]
  (let [camera (:camera initial-context)
        scene (:scene initial-context)
        palette (c/random-palette)
        ;bgcolor (-> (rand-nth palette)
        ;            (tc/random-analog 0.1 0.2 0.0)
        ;            tc/as-int24
        ;            :col)
        bgcolor (:background-color config)
        infinite (ci/infinite-palette palette (:infinite-params config))
        splines (draw-fields (:scene initial-context) (make-fields) infinite)
        [xmin xmax] (calculate-x-extents splines)
        pivot-pos (THREE.Vector3. (:x (m/div (m/+ xmax xmin) 2)) 0 0)]
    (setup-camera camera pivot-pos)
    (set! (.-position camera-pivot) pivot-pos)
    (.add camera-pivot camera)
    (.add scene camera-pivot)

    (.setClearColor (:renderer initial-context) bgcolor 1.0)
    initial-context))

(defn reload [context]
  (let [scene (:scene context)]
    (u/clear-scene scene)
    (.remove camera-pivot (:camera context))
    (setup context)))

(defn animate [context]
  (let [rot (.-x (.-rotation camera-pivot))]
    (set! (.-x (.-rotation camera-pivot)) (+ rot (:rotation-speed config)))
    context))
